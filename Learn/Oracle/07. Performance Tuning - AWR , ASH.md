# Oracle AWR and ASH: Complete Learning Guide
## From Beginner to Professional Level

---

# Table of Contents

1. [Introduction](#introduction)
2. [Prerequisites](#prerequisites)
3. [Oracle Performance Monitoring Fundamentals](#oracle-performance-monitoring-fundamentals)
4. [Understanding Oracle Wait Events](#understanding-oracle-wait-events)
5. [Dynamic Performance Views (V$ Views)](#dynamic-performance-views)
6. [Oracle Statspack vs AWR](#oracle-statspack-vs-awr)
7. [Oracle Diagnostic Pack Licensing](#oracle-diagnostic-pack-licensing)
8. [Setting Up Performance Monitoring Environment](#setting-up-performance-monitoring-environment)
9. [Oracle Enterprise Manager and Performance Hub](#oracle-enterprise-manager-and-performance-hub)
10. [Performance Tuning Methodology](#performance-tuning-methodology)
11. [Common Performance Issues and Identification](#common-performance-issues-and-identification)

## Chapter 12: Automatic Workload Repository (AWR)

### 12.1 Introduction to AWR
### 12.2 AWR Architecture and Components
### 12.3 AWR Configuration and Management
### 12.4 Generating AWR Reports
### 12.5 AWR Report Analysis - Beginner Level
### 12.6 AWR Report Analysis - Intermediate Level
### 12.7 AWR Report Analysis - Advanced Level
### 12.8 AWR Data Mining and Custom Queries
### 12.9 AWR Best Practices and Troubleshooting
### 12.10 AWR in RAC Environment

## Chapter 13: Active Session History (ASH)

### 13.1 Introduction to ASH
### 13.2 ASH Architecture and Data Collection
### 13.3 ASH Configuration and Management
### 13.4 Generating ASH Reports
### 13.5 ASH Report Analysis - Beginner Level
### 13.6 ASH Report Analysis - Intermediate Level
### 13.7 ASH Report Analysis - Advanced Level
### 13.8 ASH Data Mining and Custom Analysis
### 13.9 ASH Best Practices and Troubleshooting
### 13.10 Combining AWR and ASH for Performance Analysis

---

# Introduction

Oracle Database performance tuning is a critical skill for database administrators and developers. Two of the most powerful tools in Oracle's performance monitoring arsenal are the Automatic Workload Repository (AWR) and Active Session History (ASH). This comprehensive guide will take you from beginner to professional level understanding of these essential performance tuning tools.

# Prerequisites

Before diving into AWR and ASH, ensure you have:
- Basic understanding of Oracle Database architecture
- Knowledge of SQL and PL/SQL
- Understanding of database performance concepts
- Access to Oracle Database 10g or later
- Oracle Diagnostic Pack license (for AWR/ASH features)

# Oracle Performance Monitoring Fundamentals

## Database Performance Metrics

### Key Performance Indicators (KPIs)
- **Response Time**: Time taken to complete user requests
- **Throughput**: Number of transactions processed per unit time
- **Resource Utilization**: CPU, Memory, I/O usage
- **Concurrency**: Number of simultaneous users/sessions

### Oracle Time Model
Oracle uses a hierarchical time model to track where database time is spent:
- **DB Time**: Total time spent in database calls
- **DB CPU**: Time spent using CPU
- **Wait Time**: Time spent waiting for resources

## Performance Tuning Methodology

1. **Identify the Problem**: Define performance issues clearly
2. **Collect Data**: Gather performance statistics
3. **Analyze Data**: Identify bottlenecks and root causes
4. **Implement Solutions**: Apply appropriate tuning techniques
5. **Monitor Results**: Verify improvements and prevent regressions

---

# Chapter 12: Automatic Workload Repository (AWR)

## 12.1 Introduction to AWR

The Automatic Workload Repository (AWR) is Oracle's built-in performance monitoring and analysis tool, collecting, processing, and maintaining performance statistics for problem detection and self-tuning purposes. AWR provides a comprehensive view of database performance over time, making it essential for both reactive troubleshooting and proactive performance management.

### What is AWR?
AWR is a repository of historical performance data that includes:
- Database and instance statistics
- Object statistics
- Performance metrics
- Configuration parameters
- Resource utilization data

### Key Benefits of AWR
- **Historical Analysis**: Compare current performance with historical baselines
- **Trend Analysis**: Identify performance patterns over time
- **Capacity Planning**: Forecast future resource requirements
- **Problem Diagnosis**: Identify performance bottlenecks and their root causes
- **Automated Collection**: Minimal overhead with automatic data collection

## 12.2 AWR Architecture and Components

### AWR Data Collection Process

1. **Snapshot Collection**: AWR automatically takes periodic snapshots of performance data
2. **Data Storage**: Snapshots are stored in the SYSAUX tablespace
3. **Data Retention**: Historical data is maintained based on retention policies
4. **Report Generation**: Data is formatted into comprehensive reports

### AWR Components

#### System Global Area (SGA) Components
- **Shared Pool**: Stores AWR metadata and cursors
- **Buffer Cache**: May impact AWR data collection performance
- **Large Pool**: Used for parallel query operations in AWR

#### Background Processes
- **MMON (Manageability Monitor)**: Main AWR coordinator process
- **MMNL (Manageability Monitor Light)**: Flushes ASH data to disk
- **SMCO (Space Management Coordinator)**: Manages AWR space usage

#### Data Dictionary Views
- **DBA_HIST_** views: Historical performance data
- **V$** views: Current instance statistics
- **GV$** views: Global views for RAC environments

### AWR Data Collection Levels

Oracle provides different levels of AWR statistics collection:

**STATISTICS_LEVEL Parameter Values:**
- **BASIC**: Minimal statistics collection (not recommended)
- **TYPICAL**: Standard collection level (default)
- **ALL**: Maximum statistics collection

```sql
-- Check current statistics level
SELECT value FROM v$parameter WHERE name = 'statistics_level';

-- Change statistics level (requires restart)
ALTER SYSTEM SET statistics_level = 'ALL' SCOPE=SPFILE;
```

## 12.3 AWR Configuration and Management

### AWR Snapshot Configuration

#### Viewing Current AWR Settings
```sql
-- Check AWR configuration
SELECT snap_interval, retention, topnsql 
FROM dba_hist_wr_control;

-- View snapshot history
SELECT snap_id, begin_interval_time, end_interval_time,
       startup_time, instance_number
FROM dba_hist_snapshot
ORDER BY snap_id DESC;
```

#### Modifying AWR Settings
```sql
-- Change snapshot interval and retention
BEGIN
    DBMS_WORKLOAD_REPOSITORY.MODIFY_SNAPSHOT_SETTINGS(
        interval => 30,          -- 30 minutes
        retention => 10080       -- 7 days (in minutes)
    );
END;
/

-- Create manual snapshot
BEGIN
    DBMS_WORKLOAD_REPOSITORY.CREATE_SNAPSHOT();
END;
/
```

### AWR Snapshot Management

#### Best Practices for Snapshot Intervals
- **High-Transaction Systems**: 15-30 minutes
- **Batch Processing Systems**: 60 minutes
- **Development Systems**: 60 minutes or longer
- **Critical Production Systems**: 15 minutes during peak hours

#### Managing AWR Space
```sql
-- Check AWR space usage
SELECT occupant_name, space_usage_kbytes
FROM v$sysaux_occupants
WHERE occupant_name = 'SM/AWR';

-- Purge old snapshots
BEGIN
    DBMS_WORKLOAD_REPOSITORY.DROP_SNAPSHOT_RANGE(
        low_snap_id => 100,
        high_snap_id => 200
    );
END;
/
```

## 12.4 Generating AWR Reports

### Types of AWR Reports

#### 1. AWR Report (awrrpt.sql)
- Standard single-instance report
- Compares two snapshots
- Provides comprehensive performance analysis

#### 2. AWR Compare Period Report (awrddrpt.sql)
- Compares two different time periods
- Useful for before/after analysis
- Helps identify performance regressions

#### 3. AWR Global Report (awrgrpt.sql)
- RAC-specific report
- Provides cluster-wide performance view
- Includes all instances in RAC environment

### Generating AWR Reports

#### Using SQL*Plus Scripts
```sql
-- Generate standard AWR report
@$ORACLE_HOME/rdbms/admin/awrrpt.sql

-- Generate AWR compare report
@$ORACLE_HOME/rdbms/admin/awrddrpt.sql

-- Generate AWR global report (RAC)
@$ORACLE_HOME/rdbms/admin/awrgrpt.sql
```

#### Using DBMS_WORKLOAD_REPOSITORY Package
```sql
-- Generate AWR report using PL/SQL
DECLARE
    l_report CLOB;
BEGIN
    l_report := DBMS_WORKLOAD_REPOSITORY.AWR_REPORT_TEXT(
        l_dbid => 123456789,
        l_inst_num => 1,
        l_bid => 1000,
        l_eid => 1001
    );
    
    -- Output or save the report
    DBMS_OUTPUT.PUT_LINE(l_report);
END;
/
```

#### Report Format Options
- **HTML**: Rich formatting with navigation
- **TEXT**: Plain text for automated processing
- **XML**: Structured data for custom analysis

## 12.5 AWR Report Analysis - Beginner Level

### Understanding AWR Report Structure

#### Report Header Section
The AWR report begins with essential database information:

**Key Metrics to Review:**
- **DB Time**: Total time spent in database calls
- **Elapsed Time**: Wall-clock time for the snapshot period
- **CPUs**: Number of CPUs available to the instance
- **Startup Time**: When the database was last started

**Time Units Used in AWR:**
- **s**: second
- **cs**: centisecond (1/100th of a second)
- **ms**: millisecond (1/1000th of a second)
- **us**: microsecond (1/1000000th of a second)

#### Load Profile Section
The load profile shows average per-second and per-transaction metrics:

**Critical Metrics:**
- **DB Time (s)**: Average active sessions = DB Time / Elapsed Time
- **DB CPU (s)**: CPU time consumed by user processes
- **Logical Reads**: Buffer cache reads (consistent gets + db block gets)
- **Physical Reads**: Disk reads when data not in buffer cache
- **Hard Parses**: SQL statements requiring complete parsing
- **Soft Parses**: SQL statements reusing existing parse trees

**Analysis Tips:**
- High hard parse ratio (>2-3%) indicates bind variable issues
- Physical reads should be minimized through proper indexing
- Redo size indicates DML activity volume

#### Instance Efficiency Percentages
Key efficiency ratios to monitor:

**Buffer Hit %**: Should be >90% for OLTP systems
```
Buffer Hit % = (Logical Reads - Physical Reads) / Logical Reads * 100
```

**Soft Parse %**: Should be >95%
```
Soft Parse % = (Parses - Hard Parses) / Parses * 100
```

**Execute to Parse %**: Should be >90%
```
Execute to Parse % = (Executes - Parses) / Executes * 100
```

### Top Wait Events Analysis

#### Understanding Wait Events
Wait events indicate where the database is spending time when not using CPU:

**Common Wait Event Categories:**
- **Application**: Locks, user I/O waits
- **Concurrency**: Buffer busy waits, latch free
- **System I/O**: db file sequential read, db file scattered read
- **User I/O**: Direct path reads/writes
- **Network**: SQL*Net waits

#### Key Wait Events to Monitor

**db file sequential read**
- Indicates single-block I/O operations
- Usually from index range scans
- Average I/O response time should be <10ms for good performance

**db file scattered read**
- Indicates multi-block I/O operations
- Usually from full table scans
- May indicate missing or inefficient indexes

**log file sync**
- Commit processing wait
- Should average <10ms for good performance
- High waits may indicate I/O bottlenecks

### Host CPU and Instance CPU Analysis

#### Host CPU Section
- **CPUs**: Total number of CPU threads
- **Load Average**: System load compared to CPU count
- **%Idle**: Percentage of CPU time idle

#### Instance CPU Section
- **%Total CPU**: Database's share of total CPU
- **%Busy CPU**: Database CPU utilization
- **%DB CPU**: User process CPU time

**Analysis Guidelines:**
- If %Idle is low and %Total CPU is high: CPU bottleneck
- If %Idle is high but DB CPU is top wait event: Inefficient SQL

## 12.6 AWR Report Analysis - Intermediate Level

### SQL Statistics Analysis

#### SQL Ordered by Elapsed Time
Identifies the most time-consuming SQL statements:

**Key Columns:**
- **Elapsed Time (s)**: Total execution time
- **Executions**: Number of times executed
- **Elapsed per Exec (s)**: Average execution time
- **%Total**: Percentage of total DB time

**Analysis Approach:**
1. Focus on SQL with high total elapsed time
2. Look for SQL with few executions but high elapsed time per execution
3. Consider both high-frequency and long-running queries

#### SQL Ordered by CPU Time
Shows SQL consuming the most CPU resources:

**Analysis Tips:**
- High CPU time with low logical reads: CPU-intensive operations
- High CPU time with high logical reads: Inefficient data access patterns
- Compare with elapsed time to identify CPU vs. wait time issues

#### SQL Ordered by Gets (Logical Reads)
Identifies SQL performing the most logical I/O:

**Key Metrics:**
- **Buffer Gets**: Total logical reads
- **Gets per Exec**: Logical reads per execution
- **%Total**: Percentage of total logical reads

**Optimization Opportunities:**
- High gets per execution indicates inefficient access patterns
- Missing or inappropriate indexes
- Need for SQL tuning or rewriting

#### SQL Ordered by Physical Reads
Shows SQL performing the most disk I/O:

**Analysis Focus:**
- High physical reads may indicate:
  - Missing indexes causing full table scans
  - Insufficient buffer cache
  - Large data set processing

### Segment Statistics Analysis

#### Segments by Logical Reads
Identifies the most frequently accessed database objects:

**Use Cases:**
- Identify hot tables and indexes
- Plan for partitioning strategies
- Optimize frequently accessed objects

#### Segments by Physical Reads
Shows objects causing the most disk I/O:

**Analysis Approach:**
- High physical reads on specific segments may indicate missing indexes or inefficient SQL
- Compare with SQL statistics to correlate object access patterns
- Consider buffer cache sizing for frequently accessed objects

### Wait Event Analysis Deep Dive

#### Buffer Busy Waits
Indicates contention for specific buffer blocks:

**Common Causes:**
- Hot blocks in frequently accessed tables
- Insufficient freelists in table definitions
- High-concurrency applications accessing same data

**Resolution Strategies:**
- Increase freelists and freelist groups
- Consider table partitioning
- Review application design for hot spots

#### Latch Contention
Shows contention for internal Oracle structures:

**Key Latches to Monitor:**
- **Shared pool latch**: Indicates parsing issues
- **Cache buffers chains**: Buffer cache contention
- **Library cache**: Shared pool sizing issues

### Time Model Statistics

#### Understanding Time Breakdown
Time model statistics show where database time is consumed:

**Key Statistics:**
- **sql execute elapsed time**: Time spent executing SQL
- **parse time elapsed**: Time spent parsing SQL
- **hard parse elapsed time**: Time spent on hard parsing
- **PL/SQL execution elapsed time**: Time in PL/SQL code

## 12.7 AWR Report Analysis - Advanced Level

### Advanced Performance Analysis Techniques

#### Database Time Analysis
Understanding the relationship between different time components:

```sql
-- Query to analyze time model statistics
SELECT stat_name,
       value / 1000000 AS seconds,
       ROUND(value / SUM(value) OVER () * 100, 2) AS pct_total
FROM v$sys_time_model
WHERE value > 0
ORDER BY value DESC;
```

#### Workload Characterization
Classify your workload based on AWR metrics:

**OLTP Characteristics:**
- High user calls per second
- Low rows per execution
- High parse-to-execute ratio
- Short elapsed times per SQL

**Batch/DW Characteristics:**
- Low user calls per second
- High rows per execution
- Low parse-to-execute ratio
- Long elapsed times per SQL

### Advanced SQL Analysis

#### Version Count Analysis
Identify SQL with multiple child cursors:

```sql
-- Find SQL with high version counts
SELECT sql_id,
       COUNT(*) AS version_count,
       MIN(plan_hash_value) AS min_plan_hash,
       MAX(plan_hash_value) AS max_plan_hash
FROM v$sql
GROUP BY sql_id
HAVING COUNT(*) > 10
ORDER BY version_count DESC;
```

#### Plan Instability Detection
Identify SQL with changing execution plans:

**Indicators:**
- Multiple plan hash values for same SQL_ID
- Varying execution statistics between snapshots
- Different resource consumption patterns

### Memory Analysis

#### SGA Target Advisory
Analyze the effectiveness of SGA sizing:

**Key Metrics:**
- **Size Factor**: Relative size compared to current
- **Est DB Time**: Estimated database time with different sizes
- **Est Physical Reads**: Projected I/O with size changes

#### PGA Target Advisory
Optimize Program Global Area sizing:

**Analysis Points:**
- **Estd PGA Overalloc Count**: Should be 0
- **Estd Extra Bytes Read**: Additional I/O due to PGA constraints
- **Estd PGA Cache Hit %**: Effectiveness of PGA memory

### Advanced Wait Event Analysis

#### Enqueue Analysis
Detailed analysis of locking and resource contention:

**Common Enqueues:**
- **TX**: Transaction locks (row-level locking)
- **TM**: DML locks (table-level locking)
- **UL**: User-defined locks

#### I/O Analysis
Comprehensive analysis of I/O patterns:

**File I/O Statistics:**
- Identify hot files and tablespaces
- Analyze read/write patterns
- Optimize storage layout

**Tablespace I/O Stats:**
- **Av Rd(ms)**: Average read time (<10ms ideal)
- **Av Buf Wt(ms)**: Average buffer wait time
- **Buffer Hit%**: Tablespace-level cache efficiency

## 12.8 AWR Data Mining and Custom Queries

### Accessing AWR Data Directly

#### Key AWR Views
```sql
-- Historical snapshots
SELECT * FROM dba_hist_snapshot;

-- System statistics
SELECT * FROM dba_hist_sysstat;

-- Wait events
SELECT * FROM dba_hist_system_event;

-- SQL statistics
SELECT * FROM dba_hist_sqlstat;

-- Active Session History
SELECT * FROM dba_hist_active_sess_history;
```

### Custom AWR Analysis Queries

#### Top SQL by Resource Consumption
```sql
-- Top SQL by elapsed time over last 7 days
WITH sql_stats AS (
    SELECT sql_id,
           SUM(elapsed_time_delta) / 1000000 AS elapsed_seconds,
           SUM(executions_delta) AS total_executions,
           SUM(buffer_gets_delta) AS total_gets
    FROM dba_hist_sqlstat s
    JOIN dba_hist_snapshot sn USING (snap_id, dbid, instance_number)
    WHERE sn.begin_interval_time >= SYSDATE - 7
    GROUP BY sql_id
)
SELECT sql_id,
       elapsed_seconds,
       total_executions,
       ROUND(elapsed_seconds / NULLIF(total_executions, 0), 3) AS avg_elapsed,
       total_gets
FROM sql_stats
WHERE elapsed_seconds > 0
ORDER BY elapsed_seconds DESC
FETCH FIRST 10 ROWS ONLY;
```

#### Historical Performance Trends
```sql
-- Daily performance trends
SELECT TRUNC(begin_interval_time) AS day,
       AVG(db_time) / 1000000 AS avg_db_time_seconds,
       AVG(cpu_time) / 1000000 AS avg_cpu_seconds,
       COUNT(*) AS snapshot_count
FROM (
    SELECT s.begin_interval_time,
           st.value AS db_time,
           LAG(st.value) OVER (ORDER BY s.snap_id) AS prev_db_time,
           cpu.value AS cpu_time,
           LAG(cpu.value) OVER (ORDER BY s.snap_id) AS prev_cpu_time
    FROM dba_hist_snapshot s
    JOIN dba_hist_sys_time_model st ON (s.snap_id = st.snap_id 
                                       AND s.dbid = st.dbid 
                                       AND s.instance_number = st.instance_number)
    JOIN dba_hist_sys_time_model cpu ON (s.snap_id = cpu.snap_id 
                                        AND s.dbid = cpu.dbid 
                                        AND s.instance_number = cpu.instance_number)
    WHERE st.stat_name = 'DB time'
      AND cpu.stat_name = 'DB CPU'
      AND s.begin_interval_time >= SYSDATE - 30
) t
WHERE prev_db_time IS NOT NULL
GROUP BY TRUNC(begin_interval_time)
ORDER BY day;
```

### Performance Baseline Creation

#### Creating Performance Baselines
```sql
-- Create a baseline for normal business hours
BEGIN
    DBMS_WORKLOAD_REPOSITORY.CREATE_BASELINE(
        start_snap_id => 1000,
        end_snap_id => 1100,
        baseline_name => 'NORMAL_BUSINESS_HOURS',
        expiration => SYSDATE + 365
    );
END;
/

-- View existing baselines
SELECT baseline_name, start_snap_id, end_snap_id, 
       creation_time, expiration
FROM dba_hist_baseline;
```

## 12.9 AWR Best Practices and Troubleshooting

### AWR Collection Best Practices

#### Optimal Configuration Settings
1. **Statistics Level**: Set to TYPICAL or ALL
2. **Snapshot Interval**: 15-30 minutes for production
3. **Retention Period**: 7-14 days minimum
4. **Manual Snapshots**: Before/after major changes

#### Data Collection Guidelines
- **Multiple Reports**: Compare good vs. bad periods
- **Specific Time Frames**: Focus on problem windows
- **Shorter Intervals**: Break long reports into smaller periods
- **RAC Considerations**: Analyze all instances

### Common AWR Issues and Solutions

#### Issue: Missing or Incomplete Data
**Causes:**
- STATISTICS_LEVEL set to BASIC
- Insufficient SYSAUX tablespace
- AWR retention too short

**Solutions:**
```sql
-- Check statistics level
ALTER SYSTEM SET statistics_level = 'TYPICAL';

-- Increase SYSAUX tablespace
ALTER TABLESPACE sysaux ADD DATAFILE 
  '/path/to/sysaux02.dbf' SIZE 4G AUTOEXTEND ON;

-- Increase retention
BEGIN
    DBMS_WORKLOAD_REPOSITORY.MODIFY_SNAPSHOT_SETTINGS(
        retention => 20160  -- 14 days
    );
END;
/
```

#### Issue: High AWR Collection Overhead
**Symptoms:**
- Performance degradation during snapshot collection
- High MMON process CPU usage
- Long-running AWR queries

**Solutions:**
- Reduce snapshot frequency during peak hours
- Increase SYSAUX tablespace to avoid space pressure
- Monitor AWR-related wait events

### AWR Maintenance Procedures

#### Regular Maintenance Tasks
```sql
-- Clean up old snapshots beyond retention
BEGIN
    DBMS_WORKLOAD_REPOSITORY.PURGE_SNAPSHOT_RANGE(
        low_snap_id => 1,
        high_snap_id => 500
    );
END;
/

-- Check AWR space usage
SELECT occupant_name, 
       space_usage_kbytes / 1024 AS space_usage_mb,
       schema_name
FROM v$sysaux_occupants
WHERE occupant_name LIKE '%AWR%';

-- Monitor MMON performance
SELECT name, time_waited_micro / 1000000 AS seconds_waited
FROM v$system_event
WHERE name LIKE '%MMON%';
```

## 12.10 AWR in RAC Environment

### RAC-Specific Considerations

#### Global vs. Instance-Specific Analysis
- **Global Reports**: Cluster-wide performance view
- **Instance Reports**: Node-specific analysis
- **Cross-Instance Waits**: RAC-specific wait events

#### RAC-Specific Wait Events
- **gc cr request**: Global cache consistent read
- **gc current request**: Global cache current block
- **gc buffer busy**: Global cache buffer busy
- **gcs remote message**: Global cache services messaging
- **ges remote message**: Global enqueue services messaging

### Generating RAC AWR Reports

#### Global AWR Report
```sql
-- Generate global AWR report
@$ORACLE_HOME/rdbms/admin/awrgrpt.sql

-- PL/SQL approach for global report
DECLARE
    l_report CLOB;
BEGIN
    l_report := DBMS_WORKLOAD_REPOSITORY.AWR_GLOBAL_REPORT_TEXT(
        l_dbid => :dbid,
        l_inst_num_list => '1,2,3,4',  -- All instances
        l_bid => :begin_snap,
        l_eid => :end_snap
    );
END;
/
```

#### RAC Load Balancing Analysis
```sql
-- Compare load across RAC instances
SELECT instance_number,
       SUM(executions_delta) AS total_executions,
       SUM(elapsed_time_delta) / 1000000 AS elapsed_seconds,
       COUNT(DISTINCT sql_id) AS unique_sql_count
FROM dba_hist_sqlstat
WHERE snap_id BETWEEN :begin_snap AND :end_snap
GROUP BY instance_number
ORDER BY instance_number;
```

### RAC Performance Optimization

#### Inter-node Communication Optimization
- Monitor gc wait events
- Analyze interconnect performance
- Optimize application partitioning

#### Instance-Specific Tuning
- Balance workload across instances
- Configure services appropriately
- Monitor resource usage by instance

---
