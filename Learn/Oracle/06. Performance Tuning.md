## Chapter 1: Selectivity and Cardinality

Performance tuning is one area where most Junior DBAs face those tough-to-break problems. The kind of problems which require deep understanding of the concepts before you can even point what is going wrong in the system. We will be going through the basics knowledge in the Performance Tuning area in series of posts.

### Selectivity

**Definition**: It represents the fraction of rows filtered by an operation, so you can say it is a measure of uniqueness.

#### Key Characteristics:
- **Range**: Its value is between 0 and 1
- **Calculation**: selectivity = (rows returned after filter) / (total rows before filter)

#### Examples:

**Example 1 - Good Selectivity:**
- Query returned 100 rows initially
- After applying filter (WHERE condition), final result is 10 rows
- Selectivity = 10/100 = 0.1 (or 10%)
- This is **GOOD selectivity** because the filter significantly reduced the result set

**Example 2 - Bad Selectivity:**
- Query returned 200 rows initially  
- After applying filter, final result is still 200 rows
- Selectivity = 200/200 = 1.0 (or 100%)
- This is **BAD selectivity** because the filter didn't reduce the result set at all

#### Selectivity Classifications:

**GOOD Selectivity:**
- A column is highly selective if a SQL returns a small number of duplicate rows
- Means the filter is effective at narrowing down results
- Results in better performance

**BAD Selectivity:**
- A column is least selective if a SQL returns all or large number of rows
- Means the filter is not effective
- Results in poor performance

#### Important Notes:
- When you run `SELECT * FROM EMP` without any filters, selectivity will be automatically 1 as all rows will be returned
- **Adding a composite Index** is the best way to make BAD selectivity become GOOD selectivity
- Using more than one column makes the Index more unique which improves Index selectivity

### Cardinality

**Definition**: The number of rows returned by an operation is the cardinality.

#### Relationship Formula:
```
cardinality = selectivity × number of input rows
```

#### Practical Example:
- Query initially retrieved 200 records from database
- After applying filters, final number of rows is 50
- **Selectivity** = 50/200 = 0.25 (25%)
- **Cardinality** = 50 (or 200 × 0.25 = 50)

#### Impact on Performance:
Sometimes the Oracle optimizer is not able to predict the number of rows that a given operator will return due to reasons like:
- Missing table statistics
- Outdated statistics
- Complex predicates

This can prevent Oracle from estimating the cost of a query plan correctly, which can lead to:
- Selection of suboptimal execution plans
- Cardinality estimation errors
- Slow running queries

### Detailed Examples

#### Example 1: Query Without Filter
```sql
SELECT MAX(EMP_NUMBER) FROM EMP;
```
**Scenario**: Table EMP has 10 records total

**Analysis**:
- **Selectivity** = number of rows accessed / total number of rows = 10/10 = 1.0
- **Interpretation**: 100% of the rows were accessed
- **Cardinality** = number of rows accessed = 10

#### Example 2: Query With Filter  
```sql
SELECT MAX(EMP_NUMBER) FROM EMP WHERE LAST_NAME = 'SMITH';
```
**Scenario**: Only 4 employees have LAST_NAME as 'SMITH' out of 10 total records

**Analysis**:
- **Selectivity** = number of rows accessed / total number of rows = 4/10 = 0.4
- **Interpretation**: 40% of the rows were accessed
- **Cardinality** = number of rows accessed = 4

This demonstrates how adding a selective filter condition improves selectivity from 1.0 to 0.4, making the query more efficient.

---

## Chapter 2: Parsing

From performance tuning perspectives, it is very important to understand the concept of parsing. Parsing is the primary phase in SQL execution, followed by other stages: Execute and Fetch.

### Parsing Basics

Whenever a SQL statement is executed, the Oracle Engine performs the following actions:

1. **Validate the Syntax** - Check if the SQL statement is syntactically correct
2. **Validate the Objects** - Verify that all objects referenced in the statement exist
3. **Check Privileges** - Ensure the user has necessary privileges to execute the statement
4. **Search Shared Pool** - Verify if the statement is already available in the shared pool by:
   - Oracle engine calculates the hash value for the SQL statement
   - Looks in the shared pool for matching hash
5. **Allocate Memory** - If statement is not present, allocate shared memory and create a cursor in shared pool
6. **Generate Execution Plan** - Create the optimal execution plan for the statement

### Types of Parses

#### Hard Parse

**Definition**: A hard parse occurs when the statement is not available in shared memory or this is a brand new statement that the user is trying to execute.

**When Hard Parse Occurs**:
- Statement has never been executed before
- Statement was aged out of shared pool due to memory pressure
- Statement text doesn't exactly match existing statements (even case sensitivity matters)

**Process**: All parsing steps (1-6 above) need to be completed

**Impact**: 
- Requires extra system resources
- CPU-intensive operation
- Also known as **'Library Cache Miss'**

#### Soft Parse

**Definition**: A soft parse occurs when the statement was executed earlier, was already parsed, and is available in memory.

**Process**: Oracle only needs to perform steps 1-3 (syntax validation, object validation, privilege check) since the remaining tasks were already completed earlier.

**Benefits**:
- Much faster than hard parse
- Minimal resource consumption
- Also known as **'Library Cache Hit'**
- Follows the principle: "work hard once and reap benefits multiple times"

### Why Hard Parses Should Be Avoided

There are two key reasons why hard parses should be kept to the bare minimum required:

#### 1. CPU Intensive Operations
- **Generation of an execution plan is a very CPU-intensive operation**
- Each hard parse consumes significant CPU resources
- High hard parse rates can lead to CPU bottlenecks

#### 2. Memory Serialization Issues
- **Memory in the shared pool is limited**
- **Memory operations are serialized** - they must happen one at a time
- Memory operations use **shared pool latches** and **library cache latches**
- When many hard parses happen simultaneously:
  - Other processes must wait in queue to get the shared pool latch
  - This creates contention and reduces overall system performance
  - Impacts both shared pool latch and library cache latch availability

### Performance Implications

#### Hard Parse Impact:
- High CPU consumption
- Memory contention
- Increased response times
- Reduced throughput
- Latch waits

#### Soft Parse Benefits:
- Low CPU consumption  
- Reduced memory operations
- Faster response times
- Higher throughput
- Better scalability

### Best Practices

1. **Use Bind Variables** - Promotes statement reuse and soft parsing
2. **Consistent SQL Text** - Ensure identical statements have identical text (case, spacing, etc.)
3. **Adequate Shared Pool Size** - Prevent aging out of frequently used statements
4. **Monitor Parse Ratios** - Track hard vs soft parse ratios
5. **Application Design** - Design applications to reuse SQL statements

### Monitoring Parsing

Key metrics to monitor:
- Hard parse rate
- Soft parse rate  
- Parse time CPU vs total CPU
- Library cache hit ratio
- Shared pool latch contention

---

## Chapter 3: Parent and Child Cursors

### What is a Cursor?

A "cursor" is a memory area in the library cache that is allocated to the SQL statement which users execute. This memory area stores key information about the SQL statement like SQL text, SQL execution plan, statistics etc.

### Why Two Kinds of Cursors?

This is by Oracle database design that you have two kinds of cursors: Parent and Child. For each SQL statement that you execute, Oracle engine will generate two cursors: parent and child cursor. Two cursors are generated because for the same SQL statement, there could be other differences like there can be different bind values or two different schema or different literals values, etc. The parent Cursor will hold the SQL statement and the child cursor will hold the information related to the differences. This essentially makes child cursor as deciding factor as to SQL statement will go for hard or soft parse.

### Parent Cursor

- It stores the SQL text of the cursor. When two statements are identical word-by-word, they will share the same parent Cursor.
- Every parent cursor would execute with at least one child cursor created for it.
- Parent cursors are represented in the view **V$SQLAREA**. VERSION_COUNT column in the v$sqlarea can tell us how many child cursors does this parent cursor have.

### Child Cursor

- Each parent has at least one child cursor and can have more than 1 child cursors also
- While parent cursor stores the SQL Text, the child cursor stores other important information related to SQL statement like:
  - Environment details
  - Statistics details
  - Bind Variables details
  - Execution Plan details
  - Bind Variables details
- Child Cursor takes less memory space as SQL Text is not stored in child cursor
- Every child cursor must belong to a parent
- Child cursor decides whether a query will undergo a hard parse or a soft parse. You may find situation that SQL query is same for two statements so Parent cursors are same but the child cursor is not shareable to SQL goes for hard parse (re-compile).
- Child cursors are represented in the view **V$SQL**
- **V$SQL_SHARED_CURSOR** is very useful view as it provides the reasons why the optimizer decided mark the cursor as un-shared. So anytime you see that SQL statement was same and still hard parse happened, look at this view.

### V$SQL_SHARED_CURSOR View

This view explains why a particular child cursor is not shared with existing child cursors which caused more than one child cursor to be created for same Parent cursor. Each column in this view identifies a specific reason why the cursor cannot be shared. The columns describe the various reasons with "Y" or "N" for the value. You should focus on the column which has value as 'Y'. A specific child may have failed sharing for several reasons – ie: a different reason for trying to use different existing child cursors.

### CURSOR_SHARING Database Parameter

Since we are discussing parent and child cursors, it is very important that we discuss a bit about the cursor_sharing database parameter. CURSOR_SHARING determines what kind of SQL statements can share the same cursors.

cursor_sharing database parameters can have three different values:

#### EXACT
Only allows statements with identical text to share the same cursor.

#### FORCE
Forces statements that may differ in some literals, but are otherwise identical, to share a cursor, unless the literals affect the meaning of the statement.

#### SIMILAR
Causes statements that may differ in some literals, but are otherwise identical, to share a cursor, unless the literals affect either the meaning of the statement or the degree to which the plan is optimized.

### Examples of Different SQL Statements

The default cursor_sharing criteria is EXACT which means that each different SQL statement a new parent cursor is created. Example, below are two different SQL statements:

```sql
select * from EMP WHERE EMP_ID=1;
select * from EMP where EMP_ID=1;
```

These are two different SQLs although both will produce same result. "where" is written in capital letter in first statement while in the second statement it is written in small letters.

Even below two statements are two different SQLs:

```sql
select * from EMP where EMP_ID=1;
select * from EMP where EMP_ID=2;
```

These are different SQLs as literal values (1 and 2) are different. Executing above will create two Parent cursors if cursor_sharing parameter is EXACT.

Whereas, if you put cursor_sharing criteria is FORCE or SIMILAR, executing above two SQLs will generate single Parent cursor. When we do this, Oracle strips out all the literals from the query and replaces them with bind variables in the optimization phase. Please keep in mind that making cursor_sharing is not always an advantage. It can prove bad for SQL performance also as we will discuss in further posts.

---

## Chapter 4: Bind Variables

### Introduction to Bind Variables

Bind variables are often known as one of the key feature for better SQL query performance. Bind variables as per Oracle documentation is a placeholder in a SQL statement that must be replaced with a valid value or value address for the statement to execute successfully. By using bind variables, you can write a SQL statement that accepts inputs or parameters at run time.

You can think of SQL query as a kind of "function" in any programming language and bind variables as "values" that you pass to the function.

### Example

```sql
-- Without bind variable (using literal)
Select * from EMP where EMP_ID=1;

-- With bind variable
Select * from EMP where EMP_ID=:a;
```

First statement uses a literal value (1) to run the query while the second SQL statement uses bind variable (:a) to run the SQL statement. The value of (:a) will be provide to Oracle at run time.

### Key Benefits of Bind Variables

Having bind variable defined in the SQL query instead of literal values (which can be different every time) will make sure that Oracle will create only one Parent Cursor for the SQL statement. Oracle look for exact text match for the SQL statement to see if it is already present in the shared pool and having a bind variable instead of literal value will save a costly hard parse every time same SQL is executed.

Bind variables are specially important in OLTP kind of environments as using bind variables enables soft parsing, which means that less processing time is spent on choosing an optimized execution plan.

### Creating Bind Variables in SQL*Plus

You create bind variables in SQL*Plus with the VARIABLE command. Example:

```sql
VARIABLE mybindVariable VARCHAR2(10)
```

### Advantages of Using Bind Variables

1. **Better Shared Pool Utilization**: Oracle Shared Pool has to hold only one statement rather than a potentially very high number.

2. **No Hard Parsing so Better Performance**: No hard parsing required for SQL statements that only differ in the values.

3. **Reduced "library cache" latch contention**: Bind variables helps in avoiding performance problems due to library cache latch contention which happens every time a hard parse is required.

### Disadvantages of Using Bind Variables

Now coming to disadvantages of using bind variables. Note that in many cases bind variables will prove excellent for improving the performance of the database but at time it may produce negative results. Bind variables can reduce the information to calculate optimal access path for (Cost Based Optimizer) CBO.

---

